// ----------------------------------------------------------------------------
// This file is subject to the terms and conditions defined in
// file 'LICENSE.txt', which is part of this source code package.
// ----------------------------------------------------------------------------
namespace Yaaf.Xmpp.IM

open Yaaf.Xmpp
open Yaaf.Xmpp.XmlStanzas
type MessageType =
    /// The message is sent in the context of a one-to-one chat conversation. A compliant client SHOULD present the message in an interface enabling one-to-one chat between the two parties, including an appropriate conversation history.
    | Chat
    /// An error has occurred related to a previous message sent by the sender (for details regarding stanza error syntax, refer to [XMPP‑CORE]). A compliant client SHOULD present an appropriate interface informing the sender of the nature of the error.
    | Error 
    /// The message is sent in the context of a multi-user chat environment (similar to that of [IRC]). A compliant client SHOULD present the message in an interface enabling many-to-many chat between the parties, including a roster of parties in the chatroom and an appropriate conversation history. Full definition of XMPP-based groupchat protocols is out of scope for this memo (for details see [JEP‑0045]).
    | Groupchat
    /// The message is probably generated by an automated service that delivers or broadcasts content (news, sports, market information, RSS feeds, etc.). No reply to the message is expected, and a compliant client SHOULD present the message in an interface that appropriately differentiates the message from standalone messages, chat sessions, or groupchat sessions (e.g., by not providing the recipient with the ability to reply).
    | Headline
    /// The message is a single message that is sent outside the context of a one-to-one conversation or groupchat, and to which it is expected that the recipient will reply. A compliant client SHOULD present the message in an interface enabling the recipient to reply, but without a conversation history.
    | Normal
    | Other of string
    | NoType with
    member m.XmlString = 
        match m with
        | MessageType.Chat        -> "chat"
        | MessageType.Error       -> "error"
        | MessageType.Groupchat   -> "groupchat"
        | MessageType.Headline    -> "headline"
        | MessageType.Normal      -> "normal"
        | MessageType.Other s     -> s
        | MessageType.NoType      -> failwith "No message type given"
    static member Parse s =
        match s with
        | "chat"       -> MessageType.Chat       
        | "error"      -> MessageType.Error      
        | "groupchat"  -> MessageType.Groupchat  
        | "headline"   -> MessageType.Headline   
        | "normal"     -> MessageType.Normal
        | _            -> MessageType.Other s
type MessageData =
  { Subject :  (string * Langcode option) list
    Body : (string * Langcode option) list
    Thread : string option
    MessageType : MessageType } with
    static member CreateSimple msg =
        { Subject = []; Body = [ msg, None ]; Thread = None; MessageType = MessageType.Chat }


type PresenceType = 
    /// Signals that the entity is no longer available for communication.
    | Unavailable
    /// The sender wishes to subscribe to the recipient's presence.
    | Subscribe
    /// The sender has allowed the recipient to receive their presence.
    | Subscribed
    /// The sender is unsubscribing from another entity's presence.
    | Unsubscribe
    /// The subscription request has been denied or a previously-granted subscription has been cancelled.
    | Unsubscribed
    /// A request for an entity's current presence; SHOULD be generated only by a server on behalf of a user.
    | Probe
    /// An error has occurred regarding processing or delivery of a previously-sent presence stanza.
    | Error with
    member t.XmlString =
        match t with
        | Unavailable      -> "unavailable"
        | Subscribe        -> "subscribe"
        | Subscribed       -> "subscribed"
        | Unsubscribe      -> "unsubscribe"
        | Unsubscribed     -> "unsubscribed"
        | Probe            -> "probe"
        | Error            -> "error"
    static member Parse s =
        match s with
        | "unavailable"    -> Unavailable   
        | "subscribe"      -> Subscribe     
        | "subscribed"     -> Subscribed    
        | "unsubscribe"    -> Unsubscribe   
        | "unsubscribed"   -> Unsubscribed  
        | "probe"          -> Probe         
        | "error"          -> Error    
        | _ -> failwith "unknown presence type"
type ShowType = 
    /// The entity or resource is temporarily away.
    | Away
    /// The entity or resource is actively interested in chatting.
    | Chat
    /// The entity or resource is busy (dnd = "Do Not Disturb").
    | Dnd
    /// The entity or resource is away for an extended period (xa = "eXtended Away").
    | XA with
    member t.XmlString =
        match t with
        | Away    -> "away"
        | Chat    -> "chat"
        | Dnd     -> "dnd"
        | XA      -> "xa"
    static member Parse s =
        match s with
        | "away" -> Away    
        | "chat" -> Chat    
        | "dnd"  -> Dnd     
        | "xa"   -> XA
        | _ -> failwith "unknown show type"
type StatusData = (string * Langcode option) list
type PresenceData = 
  { Show : ShowType option
    Status : StatusData
    Priority : System.SByte option } with 
    /// None or Some Unavailable for initial presence
    static member Empty = { Show = None; Status = []; Priority = None }
type PresenceStatus = 
    /// Set status or initial presence
    | SetStatus of PresenceData

    /// Go offline
    | SetStatusUnavailable of StatusData

type PresenceProcessingType = 
    /// A "subscription request" is a request from a user for authorization to permanently subscribe to a contact's presence information; syntactically it is a presence stanza whose 'type' attribute has a value of "subscribe".
    | SubscriptionRequest

    /// A "subscription approval" is a approve from a contact to a user to permanently subscribe to the contact's presence information; syntactically it is a presence stanza whose 'type' attribute has a value of "subscribed".
    | SubscriptionApproval

    /// If a contact would like to cancel a subscription that it has previously granted to a user, to cancel a subscription pre-approval (Section 3.4), or to deny a subscription request, it sends a presence stanza of type "unsubscribed". 
    | DenySubscriptionRequestOrCancelSubscription

    /// If a user would like to unsubscribe from a contact's presence, it sends a presence stanza of type "unsubscribe". 
    | Unsubscribe
    
    /// Used to discover presence information on other servers
    | PresenceProbe

    /// Used to set the status of a user
    | StatusInfo of PresenceStatus

type RosterVersion = string

type SubscriptionType =
    /// the user does not have a subscription to the contact's presence, and the contact does not have a subscription to the user's presence; this is the default value, so if the subscription attribute is not included then the state is to be understood as "none" 
    | SubsNone
    /// the user has a subscription to the contact's presence, but the contact does not have a subscription to the user's presence 
    | To
    /// the contact has a subscription to the user's presence, but the user does not have a subscription to the contact's presence 
    | From
    /// the user and the contact have subscriptions to each other's presence (also called a "mutual subscription") 
    | Both with 
    member t.XmlString = 
        match t with
        | SubscriptionType.SubsNone  -> "none"  
        | SubscriptionType.To        -> "to"    
        | SubscriptionType.From      -> "from"  
        | SubscriptionType.Both      -> "both"  
    static member Parse s = 
        match s with
        | "none"   -> SubscriptionType.SubsNone
        | "to"     -> SubscriptionType.To
        | "from"   -> SubscriptionType.From
        | "both"   -> SubscriptionType.Both
        | _ -> failwithf "unknown subscription type: %s" s
    member x.HasTo =
        match x with
        | Both
        | To -> true
        | _ -> false
    member x.HasFrom =
        match x with
        | Both
        | From -> true
        | _ -> false
    member x.AddFrom() = 
        match x with
        | Both
        | From -> x
        | SubsNone -> From
        | To -> Both
    member x.AddTo() = 
        match x with
        | Both
        | To -> x
        | From -> Both
        | SubsNone -> To
    member x.RemoveFrom() = 
        match x with
        | Both -> To
        | From -> SubsNone
        | SubsNone 
        | To -> x
    member x.RemoveTo() = 
        match x with
        | Both -> From
        | To -> SubsNone
        | From 
        | SubsNone -> x

    static member OnOption f o =
        match o with
        | Some s -> f s
        | None -> f SubsNone
        
type AskType = 
    | Subscribe with
    member x.XmlString = 
        match x with
        | AskType.Subscribe -> "subscribe"
    static member Parse x = 
        match x with
        | "subscribe" -> AskType.Subscribe
        | _ -> raise <| MatchFailureException("unknown ask type", 0, 0)
type RosterItem = 
  { Jid : JabberId
    Name : string option
    // MUST NOT be included by client
    Approved : bool option
    Ask : AskType option
    Subscription : SubscriptionType option
    Groups : string list } with 
    static member CreateEmpty jid =
        { Jid = jid; Name = None; Approved = None; Subscription = None; Groups = []; Ask = None }
    member x.HasTo = x.Subscription |> SubscriptionType.OnOption (fun s -> s.HasTo)
    member x.HasFrom = x.Subscription |> SubscriptionType.OnOption (fun s -> s.HasFrom)
    member x.HasAsk = 
        x.Ask.IsSome && 
        match x.Ask.Value with
        | AskType.Subscribe -> true
    member x.HasApproved = x.Approved.IsSome && x.Approved.Value
        
type RosterChange = 
    | DeleteItem of JabberId 
    | SetItem of RosterItem

type RosterAction = 
    | GetRoster of RosterVersion option
    | RosterData of RosterItem list * RosterVersion option
    | RosterChange of RosterChange * RosterVersion option with
    member action.RosterItems
        with get() =
            match action with
            | GetRoster _ -> []
            | RosterData (list, _) -> list |> List.map (fun i -> false, i)
            | RosterChange (RosterChange.SetItem (item), _) -> [ false, item ]
            | RosterChange (DeleteItem (jid), _) -> [ true, RosterItem.CreateEmpty jid ]
    member action.RosterQueryVersion 
        with get() =
            match action with
            | GetRoster (version) 
            | RosterData (_, version) 
            | RosterChange (_, version) -> version

type MessageStanza = Stanza<MessageData>
type PresenceStanza = Stanza<PresenceProcessingType>
type RosterStanza = Stanza<RosterAction>

module Parsing =
    open System.Xml.Linq
    open Yaaf.Xml
    open Yaaf.Helper
    open Yaaf.Xmpp.XmlStanzas.Parsing
    open Yaaf.Xmpp.XmlStanzas.StanzaParseException

    let ns = KnownStreamNamespaces.abstractStreamNS
    let isContentMessage (stanza:IStanza) = 
        stanza.Header.StanzaType = XmlStanzaType.Message
    // Message
    let parseContentMessage (stanza:IStanza) =
        if stanza.Header.StanzaType <> XmlStanzaType.Message then parseFail stanza "expected message stanza" 
        else
        let body = 
            stanza.Contents.Children 
            |> Seq.filter (fun e -> e.Name = getXName "body" ns)
            |> Seq.map (fun e -> e.Value, match e.Attribute(getXName "lang" xmlNs) with null -> None | d -> Some (Langcode.OfString d.Value))
            |> Seq.toList

        let subject = 
            stanza.Contents.Children 
            |> Seq.filter (fun e -> e.Name = getXName "subject" ns)
            |> Seq.map (fun e -> e.Value, match e.Attribute(getXName "lang" xmlNs) with null -> None | d -> Some (Langcode.OfString d.Value))
            |> Seq.toList
        let thread =
            stanza.Contents.Children 
            |> Seq.tryFind (fun e -> e.Name = getXName "thread" ns)
            |> Option.map (fun e -> e.Value)
        {   Body = body
            Subject = subject
            Thread = thread
            MessageType = 
                match stanza.Header.Type with
                | Some t -> MessageType.Parse t
                | None -> MessageType.NoType }

    let parseMessageStanza ns (elem:XElement) =  // parse something within the "stream"
        parseGenericStanza ns parseContentMessage elem

    let createMessageStanzaElement (content:MessageData) = 
        let subjects =
            content.Subject
                |> Seq.map 
                    (fun (s, lang) ->
                        [ 
                            yield s :> obj; 
                            if lang.IsSome then 
                                yield XAttribute(getXName "lang" xmlNs, lang.Value) :> obj] 
                        |> getXElemWithChilds (getXName "subject" ns))
                |> Seq.toList
        let bodies =
            content.Body
                |> Seq.map 
                    (fun (s, lang) ->
                        [ 
                            yield s :> obj; 
                            if lang.IsSome then 
                                yield XAttribute(getXName "lang" xmlNs, lang.Value) :> obj] 
                        |> getXElemWithChilds (getXName "body" ns))
                |> Seq.toList
        let thread = 
            if content.Thread.IsSome then
                [[ content.Thread.Value :> obj ] |> getXElemWithChilds (getXName "thread" ns)]
            else []
        subjects 
        |> List.append bodies
        |> List.append thread

    let messageContentGenerator = ContentGenerator.Of createMessageStanzaElement
    let createMessageElement (target:JabberId) (data:MessageData) = 
        let cType = 
            match data.MessageType with
            | MessageType.Chat 
            | MessageType.Error 
            | MessageType.Groupchat
            | MessageType.Headline
            | MessageType.Normal
            | MessageType.Other _ -> Some (data.MessageType.XmlString)
            | MessageType.NoType -> None
        Stanza<_>.CreateGen messageContentGenerator
          { To = Some target
            From = None
            Id = None
            Type = cType
            StanzaType = XmlStanzaType.Message }
          data

    // Presence data
    let isContentPresence (stanza:IStanza) = 
        stanza.Header.StanzaType = XmlStanzaType.Presence  
        
    let parseContentPresence (stanza:IStanza) =
        if stanza.Header.StanzaType <> XmlStanzaType.Presence then parseFail stanza "expected presence stanza"
        else
        let show =
            stanza.Contents.Children 
            |> Seq.tryFind (fun e -> e.Name = getXName "show" ns)
            |> Option.map (fun e -> e.Value)
            |> Option.map ShowType.Parse

        let status = 
            stanza.Contents.Children 
            |> Seq.filter (fun e -> e.Name = getXName "status" ns)
            |> Seq.map (fun e -> e.Value, match e.Attribute(getXName "lang" xmlNs) with null -> None | d -> Some (Langcode.OfString d.Value))
            |> Seq.toList

        let priority = 
            stanza.Contents.Children 
            |> Seq.tryFind (fun e -> e.Name = getXName "priority" ns)
            |> Option.map (fun e -> e.Value)
            |> Option.map System.SByte.Parse
        let parsedData =
            {   Show = show
                Status = status
                Priority = priority }
        match stanza.Header.Type with
        | Some "subscribe" -> SubscriptionRequest
        | Some "subscribed" -> SubscriptionApproval
        | Some "unsubscribed" -> DenySubscriptionRequestOrCancelSubscription
        | Some "unsubscribe" -> Unsubscribe
        | Some "probe" -> PresenceProbe
        | None ->  StatusInfo(SetStatus parsedData)
        | Some "unavailable" -> StatusInfo(SetStatusUnavailable parsedData.Status)
        | _ -> parseFail stanza "invalid type in presence stanza"

    let parsePresenceStanza ns (elem:XElement) =  // parse something within the "stream"
        parseGenericStanza ns parseContentPresence elem

    let createPresenceStanzaElement (presAction:PresenceProcessingType) = 
        let content =
            match presAction with
            | SubscriptionRequest 
            | SubscriptionApproval 
            | DenySubscriptionRequestOrCancelSubscription 
            | Unsubscribe
            | PresenceProbe -> PresenceData.Empty
            | StatusInfo(SetStatus data) -> data
            | StatusInfo(SetStatusUnavailable status) -> { PresenceData.Empty with Status = status }

        [ if content.Show.IsSome then
            yield [ (content.Show.Value.XmlString) :> obj ] |> getXElemWithChilds (getXName "show" ns)
          yield! // status =
            content.Status
                |> Seq.map 
                    (fun (s, lang) ->
                        [ 
                            yield s :> obj; 
                            if lang.IsSome then 
                                yield XAttribute(getXName "lang" xmlNs, lang.Value) :> obj] 
                        |> getXElemWithChilds (getXName "status" ns))
                |> Seq.toList
          // priority =
          if content.Show.IsSome then
            yield [ (content.Show.Value.XmlString) :> obj ] |> getXElemWithChilds (getXName "show" ns) ]

    let presenceContentGenerator = ContentGenerator.Of createPresenceStanzaElement
    let createPresenceElement id from toJid (presenceType:PresenceProcessingType) = 
        let presType = 
            match presenceType with
            | SubscriptionRequest -> Some "subscribe"
            | SubscriptionApproval -> Some "subscribed"
            | DenySubscriptionRequestOrCancelSubscription -> Some "unsubscribed"
            | Unsubscribe -> Some "unsubscribe"
            | PresenceProbe -> Some "probe"
            | StatusInfo(SetStatus _) -> None
            | StatusInfo(SetStatusUnavailable _) -> Some "unavailable"
        let header = 
          { To = toJid
            From = from
            Id = id
            Type = presType
            StanzaType = XmlStanzaType.Presence }
        Stanza<_>.CreateGen presenceContentGenerator header presenceType

    // Iq data (roster)
    let rosterNs = "jabber:iq:roster"
    let isContentRoster (stanza:IStanza) = 
        if stanza.Header.StanzaType <> XmlStanzaType.Iq  then false
        else
        let queryItem =
            stanza.Contents.Children 
            |> Seq.tryFind (fun e -> e.Name = getXName "query" rosterNs)
        queryItem.IsSome 

    let parseContentRosterItem (elem:XElement) = 
        let maybeSubs = elem |> tryXAttrValue (getXName "subscription" "")
        let isRemove = match maybeSubs |> Option.map (fun v -> v = "remove") with Some s -> s | None -> false
        let groups = 
            elem.Elements()
            |> Seq.filter (fun e -> e.Name = getXName "group" rosterNs) 
            |> Seq.map (fun e -> e.Value)
            |> Seq.toList
        if groups |> Seq.duplicates |> Seq.isEmpty |> not then
            elemFail elem "groups can't contain duplicates!"
        if groups |> Seq.exists System.String.IsNullOrEmpty then
            elemFail elem "groups can't contain empty group elements!"
        isRemove, 
        { Jid = 
            match elem |> tryXAttrValue (getXName "jid" "") with
            | Some e -> JabberId.Parse e
            | None -> elemFail elem "roster item without jid attribute is not expected"
          Name = elem |> tryXAttrValue (getXName "name" "")
          // MUST NOT be included by client
          Approved = elem |> tryXAttrValue (getXName "approved" "") |> Option.map System.Boolean.Parse
          Ask = elem |> tryXAttrValue (getXName "ask" "") |> Option.map AskType.Parse
          Subscription = if isRemove then None else maybeSubs |> Option.map SubscriptionType.Parse
          Groups = groups }
    let parseContentRoster (stanza:IStanza) =
        if stanza.Header.StanzaType <> XmlStanzaType.Iq then parseFail stanza "expected iq stanza"
        else
        let queryItem =
            stanza.Contents.Children 
            |> Seq.filter (fun e -> e.Name = getXName "query" rosterNs)
            |> Seq.exactlyOneExn (lazy parseExn stanza "")

        let versionAttribute =
            queryItem |> tryXAttrValue (getXName "ver" "")
        let itemList = 
            queryItem.Elements()
            |> Seq.filter (fun e -> e.Name = getXName "item" rosterNs)
            |> Seq.map (parseContentRosterItem)
            |> Seq.toList

        match stanza.Header.Type.Value with
        | "get" -> 
            assert itemList.IsEmpty
            GetRoster(versionAttribute)
        | "result" ->
            if itemList |> Seq.map fst |> Seq.exists id then
                elemFail queryItem "remove is not allowed in roster result"
            RosterData(itemList |> List.map snd, versionAttribute)
        | "set" ->
            let isRemove, item = itemList |> Seq.exactlyOneExn (lazy elemExn queryItem "there has to be exaclty one item in roster set/push")
            let change =
                if isRemove then
                    RosterChange.DeleteItem (item.Jid)
                else
                    SetItem(item)
            RosterAction.RosterChange (change, versionAttribute)
        | _ -> parseFailf stanza "unknown type in roster stanza: %s" stanza.Header.Type.Value

    let parseRosterStanza ns (elem:XElement) =  // parse something within the "stream"
        parseGenericStanza ns parseContentRoster elem
    let createRosterItemElement (isRemove: bool, item: RosterItem) = 
        if isRemove && item.Subscription.IsSome then
            failwith "cannot remote an item and set the subscription at the same time!"
        let groups = 
            item.Groups
            |> Seq.map (fun g -> [ g ] |> getXElemWithChilds (getXName "group" rosterNs) )
            |> Seq.cast
        [
            yield XAttribute(getXName "jid" "", item.Jid.FullId) :> obj
            if item.Approved.IsSome then
                yield XAttribute(getXName "approved" "", item.Approved.Value) :> obj
            if item.Ask.IsSome then
                yield XAttribute(getXName "ask" "", item.Ask.Value.XmlString) :> obj
            if item.Name.IsSome then
                yield XAttribute(getXName "name" "", item.Name.Value) :> obj
            if item.Subscription.IsSome then
                yield XAttribute(getXName "subscription" "", item.Subscription.Value.XmlString) :> obj
            if isRemove then
                yield XAttribute(getXName "subscription" "", "remove") :> obj                
            yield! groups
        ] |> getXElemWithChilds (getXName "item" rosterNs)
    let createRosterStanzaElement (content:RosterAction) = 
        let versionAttribute = 
            content.RosterQueryVersion 
        let items = 
            content.RosterItems
            |> Seq.map (createRosterItemElement)
            |> Seq.cast

        [
            if versionAttribute.IsSome then
                yield XAttribute(getXName "ver" "", versionAttribute.Value) :> obj
            yield! items
        ] |> getXElemWithChilds (getXName "query" rosterNs)

    let rosterContentGenerator = ContentGenerator.SimpleGenerator createRosterStanzaElement
    let createRosterElement (id:string) (fromJid:JabberId option) (toJid:JabberId option) (data:RosterAction) = 
        let cType = 
            match data with
            | GetRoster _ -> "get"
            | RosterData _ -> "result"
            | RosterChange _ -> "set"
        Stanza<_>.CreateGen rosterContentGenerator
          { To = toJid
            From = fromJid
            Id = Some id
            Type = Some cType
            StanzaType = XmlStanzaType.Iq }
          data